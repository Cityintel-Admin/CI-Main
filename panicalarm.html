<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>CityIntel — Panic Alarm</title>
  
<script>
(function(){
  const API_ORIGIN = (window.CI_API_ORIGIN || 'https://api.cityintelapi.com').replace(/\/+$/,'');

  // --- Shared link support (no login) ---------------------------------
  // If the URL has ?org=<ORG_ID>&token=<INVITE_OR_SHARED_TOKEN>, we will
  // send those on requests so people can trigger/reset without having a user login.
  //
  // Your Worker must accept these headers/query values on a dedicated route.
  // If your route names differ, change SHARED_* constants below.
  const qp = new URLSearchParams(location.search);
  const SHARED_ORG   = (qp.get('org') || '').trim();
  const SHARED_TOKEN = (qp.get('token') || '').trim();

  // Default routes (adjust if your Worker uses different ones)
  const SHARED_GET_PATH    = '/api/org/panic';           // can be same as normal if your worker allows shared GET
  const SHARED_SET_PATH    = '/api/org/panic/shared';    // suggested: shared trigger/reset route
  const SHARED_LOG_PATH    = '/api/org/panic/log';       // optional: recent activations (if implemented)

  function hasSharedAccess(){
    return !!(SHARED_ORG && SHARED_TOKEN);
  }

  function sharedHeaders(){
    return {
      'X-Org-Id': SHARED_ORG,
      'X-Org-Token': SHARED_TOKEN,
    };
  }

  // --- Auth / user -----------------------------------------------------
  const isLoggedIn = (window.CIAuth && CIAuth.isLoggedIn && CIAuth.isLoggedIn());
  const user = (window.CIAuth && CIAuth.getUser) ? (CIAuth.getUser() || {}) : {};
  const currentUser = isLoggedIn ? user : { email:'', name:'' };

  const el = {
    statusBadge: document.getElementById('statusBadge'),
    statusLine: document.getElementById('statusLine'),
    activate: document.getElementById('activateBtn'),
    cancel: document.getElementById('cancelBtn'),
    refresh: document.getElementById('refreshBtn'),
    msg: document.getElementById('msg'),
    first: document.getElementById('firstName'),
    last: document.getElementById('lastName'),
    loc: document.getElementById('locationText'),
  };

  // Prefill name fields from logged-in account if available
  if (currentUser?.name) {
    const parts = String(currentUser.name).trim().split(/\s+/);
    if (parts.length) el.first.value = parts[0] || '';
    if (parts.length > 1) el.last.value = parts.slice(1).join(' ') || '';
  }

  function setLine(t){ el.statusLine.textContent = t; }

  function fmtWhen(iso){
    if (!iso) return '';
    try{
      const d = new Date(iso);
      return d.toLocaleString();
    }catch{ return String(iso); }
  }

  async function api(path, opts={}){
    const headers = Object.assign(
      { 'Content-Type': 'application/json' },
      opts.headers || {}
    );

    // Logged-in path (existing)
    if (isLoggedIn && currentUser?.email) {
      headers['X-User-Email'] = currentUser.email;
      headers['X-User-Name']  = currentUser.name || '';
      if (currentUser.id) headers['X-User-Id'] = currentUser.id;
    }

    // Shared path (no login)
    if (!isLoggedIn && hasSharedAccess()) {
      Object.assign(headers, sharedHeaders());
    }

    const res = await fetch(API_ORIGIN + path, { ...opts, headers });
    const txt = await res.text();
    let data = null;
    try{ data = txt ? JSON.parse(txt) : null; }catch{ data = null; }

    if (!res.ok) {
      const msg = (data && (data.error || data.message)) ? (data.error || data.message) : (`HTTP ${res.status}`);
      throw new Error(msg);
    }
    return data;
  }

  function buildDisplayName(){
    const first = (el.first.value || '').trim();
    const last  = (el.last.value  || '').trim();
    const full = [first, last].filter(Boolean).join(' ');
    return full;
  }

  function requireIdentity(){
    // If logged-in, we still want name fields filled (for better log context),
    // but we can fallback to account name.
    const displayName = buildDisplayName() || (currentUser.name || '').trim();
    const email = (currentUser.email || '').trim();

    // Shared access: require a name because there is no user identity.
    if (!isLoggedIn) {
      if (!hasSharedAccess()) {
        throw new Error('You are not logged in. Use a shared panic link or sign in.');
      }
      if (!displayName) {
        throw new Error('Please enter your first name and surname.');
      }
    }

    return { displayName, email };
  }

  async function load(){
    setLine('Loading…');
    try{
      // prefer normal route (works for logged-in)
      let st = await api('/api/org/panic', { method:'GET' });

      const active = !!st?.data?.active;
      const by = st?.data?.byEmail || st?.data?.byName || '—';
      const when = st?.data?.at ? fmtWhen(st.data.at) : '—';
      const note = st?.data?.note ? String(st.data.note) : '';

      if (active){
        el.statusBadge.textContent = 'PANIC ALARM ACTIVE';
        el.statusBadge.style.background = 'rgba(255, 59, 48, .20)';
        el.statusBadge.style.borderColor = 'rgba(255, 59, 48, .35)';
        setLine(`Activated by: ${by} • ${when}${note ? ' • Note: ' + note : ''}`);
        el.activate.disabled = true;
        el.cancel.disabled = false;
      } else {
        el.statusBadge.textContent = 'No active panic alarm';
        el.statusBadge.style.background = 'rgba(46, 204, 113, .10)';
        el.statusBadge.style.borderColor = 'rgba(46, 204, 113, .25)';
        setLine('No active alarm for your organisation.');
        el.activate.disabled = false;
        el.cancel.disabled = true;
      }
    } catch(e){
      setLine('Load failed: ' + e.message);
    }
  }

  async function setPanic(nextActive){
    const now = new Date().toISOString();
    const ident = requireIdentity();

    const loc = (el.loc.value || '').trim();
    const msg = (el.msg.value || '').trim();

    // We store a single "note" string for now (simple v1).
    // Format is readable and easy to evolve later into structured fields.
    const noteParts = [];
    const dn = ident.displayName;
    if (dn) noteParts.push(`Name: ${dn}`);
    if (loc) noteParts.push(`Location: ${loc}`);
    if (msg) noteParts.push(`Message: ${msg}`);
    const note = noteParts.join(' | ');

    const payload = {
      active: !!nextActive,
      at: now,
      byEmail: ident.email || '',
      byName: dn || ident.email || '',
      note
    };

    // If shared access (no login), hit the shared route (recommended).
    // If your Worker allows shared PUT on /api/org/panic, you can change SHARED_SET_PATH.
    const path = (!isLoggedIn && hasSharedAccess()) ? SHARED_SET_PATH : '/api/org/panic';

    await api(path, { method:'PUT', body: JSON.stringify(payload) });
  }

  el.refresh.addEventListener('click', load);

  el.activate.addEventListener('click', async ()=>{
    try{
      if (!confirm('Activate panic alarm for your organisation?')) return;
      el.activate.disabled = true;
      await setPanic(true);
      await load();
      setLine('Panic Alarm Activated.');
    } catch(e){
      setLine('Activate failed: ' + e.message);
    } finally {
      el.activate.disabled = false;
    }
  });

  el.cancel.addEventListener('click', async ()=>{
    try{
      if (!confirm('Cancel / reset the panic alarm for your organisation?')) return;

      // ask for an optional resolution note (will be appended into note)
      const reason = prompt('Cancel / reset note (optional):', 'Resolved / false alarm') || '';
      if (reason && !el.msg.value) el.msg.value = reason;

      el.cancel.disabled = true;
      await setPanic(false);
      await load();
      setLine('Panic Alarm Cleared.');
    } catch(e){
      setLine('Reset failed: ' + e.message);
    } finally {
      el.cancel.disabled = false;
    }
  });

  // If not logged in but shared token exists, make it obvious the page is usable
  if (!isLoggedIn && hasSharedAccess()){
    const pill = document.getElementById('userPill');
    if (pill) pill.textContent = 'Shared Access';
  }

  load();
  setInterval(load, 30_000);
})();
</script>

</body>
</html>
